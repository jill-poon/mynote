# 消息中间件选型

## 消息中间件

- 优点
  - **应用解耦**
  - **弹性伸缩**
  - **冗余存储**
  - **流量削峰**
  - **异步通信**
- 缺点
  - 增加复杂度
    - 消息丢失
    - 消息重复
    - 消息有序
  - 降低可用性
    - 依赖消息队列的可用性
  - 一致性

## 选型要点

- **最大程度上**
- **开箱即用**
- **缩短项目周期**
- **降低成本**

## 1 功能维度

### 1.1 优先级队列

- 优先级高的消息具备**优先被消费**的特权
- 优先级也是需要有一个前提的：如果消费者的消费速度大于生产者的速度，并且消息中间件服务器（一般简单的称之为 Broker）中**没有消息堆积**，那么对于发送的消息设置优先级也就没有什么实质性的意义了

### 1.2 延迟队列

- 延迟队列一般分为两种：基于消息的延迟和基于队列的延迟。
- 基于消息的延迟是指**为每条消息设置不同的延迟时间**，那么每当队列中有新消息进入的时候就会**重新根据延迟时间排序**，当然这也会**对性能造成极大的影响**。
- 实际应用中**大多采用基于队列的延迟**，设置不同延迟级别的队列，比如 5s、10s、30s、1min、5mins、10mins 等，**每个队列中消息的延迟时间都是相同的**，这样**免去了延迟排序所要承受的性能之苦**，通过一定的扫描策略（比如定时）即可投递超时的消息。
- RabbitMQ 最简单的实现方式就是**设置 TTL**，然后一个消费者去监听死信队列。当消息超时了，监听死信队列的消费者就收到消息了。
  - 队列中 TTL 需要一致，消息会优先遵守队列的先进先出规则
  - rabbitmq delayed message exchange

### 1.3 死信队列

- 由于某些原因消息**无法被正确的投递**，为了确保消息不会被无故的丢弃，一般将其置于一个特殊角色的队列，这个队列一般称之为**死信队列**

### 1.4 重试队列

- 重试队列其实可以看成是一种回退队列，具体指消费端**消费消息失败时**，为防止消息无故丢失而**重新将消息回滚到 Broker 中**

### 1.5 消费模式

- **推 (push)**
  - Broker 主动推送消息至消费端，**实时性较好**，不过**需要一定的流制机制**来确保服务端推送过来的消息**不会压垮消费端**
- **拉 (pull)**
  - 消费端主动向 Broker 端请求拉取（一般是**定时或者定量**）消息，**实时性较推模式差**，但是**可以根据自身的处理能力**而**控制拉取的消息量**

### 1.6 广播消费

- **点对点（P2P，Point-to-Point）模式**
  - 对于点对点的模式而言，消息被消费以后，**队列中不会再存储**，所以消息消费者**不可能消费到已经被消费的消息**
- **发布 / 订阅（Pub/Sub）模式**
  - 一对多广播
- RabbitMQ 是一种典型的点对点模式，而 Kafka 是一种典型的发布订阅模式
  - RabbitMQ 中可以通过**设置交换器类型**来实现发布订阅模式而**达到广播消费**的效果
  - Kafka 中也能以点对点的形式消费，你完全可以把其消费组（consumer group）的概念看成是队列的概念

### 1.7 消息回溯

- 消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息
- Kafka 消息会被持久化一个专门的日志文件里。不会因为被消费了就被删除。
- RabbitMQ 此时就真的不行了，因为消息被人取出来就被删除了。

### 1.8 消息堆积 + 持久化

- **内存式堆积**
  - RabbitMQ 是**典型的内存式堆积**，但这并非绝对，在某些条件触发后会有换页动作来将内存中的消息换页到磁盘（换页动作会影响吞吐），或者直接使用惰性队列来将消息直接持久化至磁盘中
- **磁盘式堆积**
  - Kafka 是一种**典型的磁盘式堆积**，所有的**消息都存储在磁盘中**。援引 纽约时报的案例，其直接将 Kafka 用作存储系统。

### 1.9 消息追踪

- 基于此功能下，我们可以对发送或者消费完的消息进行**链路追踪服务**，进而可以进行问题的快速定位与排查。

### 1.10 消息过滤

- 消息过滤是指按照既定的过滤规则**为下游用户提供指定类别的消息**。
- RabbitMQ 是允许在消息中添加 routing_key 或者自定义消息头，然后通过一些特殊的 Exchange，很简单的就实现了消息匹配分发

### 1.11 多租户

- 多用户的环境下可以确保**各用户间数据的隔离性**。
- RabbitMQ 就能够支持多租户技术，每一个租户表示为一个 vhost，它既能将同一个 RabbitMQ 中的众多客户区分开，又可以避免队列和交换器等命名冲突。

### 1.12 多协议支持

- 一般消息层面的协议有 AMQP、MQTT、STOMP、XMPP 等
- RabbitMQ 能够支持 MQTT 协议就让其在物联网应用中获得一席之地
- Kafka 为典型的基于其本身的私有协议运转

### 1.13 跨语言支持

- 跨语言的支持力度也可以从侧面反映出一个消息中间件的流行程度

### 1.14 流量控制

- 针对的是发送方和接收方**速度不匹配**的问题
- 通常的流控方法有
  - `Stop-and-wait` (数据链路层协议)
  - `滑动窗口`
  - `令牌桶`

### 1.15 消息顺序性

- 消息顺序性是指保证消息有序
- RabbitMQ 会为每个消费者建立一个对应的队列。也就是说，如果有 10 个消费者，RabbitMQ 会建立 10 个对应的队列。然后，当一条消息被发出后，RabbitMQ 会把这条消息复制 10 份放到这 10 个队列里。RabbitMQ 线程消费出错，可以把消息重新入队的特性，此时异常消息会被重新放到队列头部。
    1. 为了实现发布订阅功能，从而使用的消息复制，会降低性能并耗费更多资源
    2. 多个消费者无法严格保证消息顺序
    3. 大量的消息集中在一个队列，吞吐量受到了限制

### 1.16 安全机制

- Kafka 和 RabbitMQ 同样提供安全机制

### 1.17 消息幂等性

- 幂等性
  - 唯一性标识、并且在下游设置一个去重表
  - 状态机
- **At most once**
  - 至多一次，消息**可能丢失**，但**绝不会重复传输**
- **At least once**
  - 至少一次，消息**绝不会丢**，但是**可能会重复**
- **Exactly once**
  - 精确一次，每条消息**肯定会被传输一次且仅一次**
  - 很难做到，由此消息幂等性也很难保证

> Kafka 自 0.11 版本开始引入了**幂等性**和**事务**，Kafka 的**幂等性是指单个生产者对于单分区单会话的幂等**，而**事务可以保证原子性地写入到多个分区**，即写入到多个分区的消息要么全部成功，要么全部回滚，这两个功能加起来可以让 Kafka 具备 EOS（Exactly Once Semantic）的能力。

### 1.18 事务性消息

- Kafka 和 RabbitMQ 都支持，不过此两者的事务是指生产者发生消息的事务，要么发送成功，要么发送失败

### 1.19 消息空洞

- 只要消息出现失败，不管是 Kafka 自身消息格式的损坏，还是消费者处理出现异常，是不允许跳过消费失败的消息继续往后消费的。所以，在**数据统计不要求十分精确**的场景下选了 Kafka，一旦出现了消息消费问题，就会发生项目不可用的情况。
- RabbitMQ 呢，它由于会在消息出问题或者消费错误的时候，可以重新入队或者移动消息到死信队列，继续消费后面的。

## 2 性能

### 2.1 吞吐量

- 消息中间件的性能一般是指其**吞吐量**

> 消息中间件的**吞吐量始终会受到硬件层面的限制**。就以网卡带宽为例，如果单机单网卡的带宽为 1Gbps，如果要达到百万级的吞吐，那么消息体大小不得超过 (1Gb/8)/100W，即约等于 134B，换句话说如果消息体大小超过 134B，那么就不可能达到百万级别的吞吐。这种计算方式同样可以适用于内存和磁盘。

### 2.2 时延

- 时延作为性能维度的一个重要指标，却往往在消息中间件领域所被忽视，因为一般使用消息中间件的场景**对时效性的要求并不是很高**
- 如果所使用的消息中间件的时延方面比较优秀，那么对于整体系统的性能将会是一个不小的提升。

## 3 可靠性

- 消息中间件的可靠性是指**对消息不丢失的保障程度**
- 对于 Kafka 而言，其采用的是类似 PacificA 的一致性协议，**通过 ISR 来保证多副本之间的同步**，并且**通过 acks 支持强一致性语义**
- 对应的 RabbitMQ 是**通过镜像环形队列实现多副本及强一致性语义**
- 在金融支付领域使用 RabbitMQ 居多，而在日志处理、大数据等方面 Kafka 使用居多

> 同步刷盘是增强一个组件可靠性的有效方式，消息中间件也不例外，Kafka 和 RabbitMQ 都可以支持同步刷盘，但是笔者对同步刷盘有一定的疑问：绝大多数情景下，一个组件的可靠性不应该由同步刷盘这种极其损耗性能的操作来保障，而是采用多副本的机制来保证。

## 4 可用性

- 消息中间件的可用性是指**无故障运行的时间百分比**，通常用几个 9 来衡量
- Kafka 的**水平扩展能力**，其基本上可以达到**线性容量提升**的水平，在 LinkedIn 实践介绍中就提及了有部署超过千台设备的 Kafka 集群

## 5 运维管理

- 对于 RabbitMQ 而言，最正统的监控管理工具莫过于 rabbitmq_management 插件了，但是社区内还有 AppDynamics, Collectd, DataDog, Ganglia, Munin, Nagios, New Relic, Prometheus, Zenoss 等多种优秀的产品
- Kafka 在此方面也毫不逊色，比如：Kafka Manager, Kafka Monitor, Kafka Offset Monitor, Burrow, Chaperone, Confluent Control Center 等产品，尤其是 Cruise 还可以提供自动化运维的功能

## 6 社区力度及生态发展

- 在运维管理维度我们提及了 Kafka 和 RabbitMQ 都有一系列开源的监控管理产品，这些正是得益于其社区及生态的迅猛发展。

## 总结

- RabbitMQ 在于 routing，而 Kafka 在于 streaming，了解其根本对于自己能够**对症下药选择到合适的消息中间件尤为重要**。
- 消息中间件选型**切忌一味的追求性能或者功能**，**性能可以优化**，**功能可以二次开发**。如果要在功能和性能方面做一个抉择的话，那么**首选性能**，因为总体上来说**性能优化的空间没有功能扩展的空间大**。然而**对于长期发展而言，生态又比性能以及功能都要重要**。
- 消息中间件选型还有一个考量标准就是**尽量贴合团队自身的技术栈体系**，虽然说没有蹩脚的消息中间件只有蹩脚的程序员，但是让一个 C 栈的团队去深挖 PhxQueue 总比去深挖 Scala 编写的 Kafka 要容易的多。
- 消息中间件大道至简：一发一存一消费，没有最好的消息中间件，**只有最合适的消息中间件**。
