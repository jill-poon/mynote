# 消息中间件选型

[消息中间件选型](../../../Middleware/MQ/消息中间件选型.md)

## 消息中间件

- 在分布式环境下提供 \_\_\_\_\_\_\_\_ 、 \_\_\_\_\_\_\_\_ 、 \_\_\_\_\_\_\_\_ 、 \_\_\_\_\_\_\_\_ 、 \_\_\_\_\_\_\_\_

## 选型要点

- 能否 \_\_\_\_\_\_\_\_ 的实现 \_\_\_\_\_\_\_\_ ，进而 \_\_\_\_\_\_\_\_ 、 \_\_\_\_\_\_\_\_

## 消息中间件选型六个维度

- \_\_\_\_\_\_\_\_
- \_\_\_\_\_\_\_\_
- \_\_\_\_\_\_\_\_
- \_\_\_\_\_\_\_\_
- \_\_\_\_\_\_\_\_
- \_\_\_\_\_\_\_\_

## 1 功能维度

### 1.1 优先级队列

- 优先级高的消息具备 \_\_\_\_\_\_\_\_ 的特权
- 优先级也是需要有一个前提的：如果消费者的消费速度大于生产者的速度，并且消息中间件服务器（一般简单的称之为 Broker）中 \_\_\_\_\_\_\_\_ ，那么对于发送的消息设置优先级也就没有什么实质性的意义了

### 1.2 延迟队列

- 延迟队列一般分为两种：基于消息的延迟和基于队列的延迟。
- 基于消息的延迟是指 \_\_\_\_\_\_\_\_ ，那么每当队列中有新消息进入的时候就会 \_\_\_\_\_\_\_\_ ，当然这也会 \_\_\_\_\_\_\_\_ 。
- 实际应用中 \_\_\_\_\_\_\_\_ ，设置不同延迟级别的队列，比如 5s、10s、30s、1min、5mins、10mins 等， \_\_\_\_\_\_\_\_ ，这样 \_\_\_\_\_\_\_\_ ，通过一定的扫描策略（比如定时）即可投递超时的消息

### 1.3 死信队列

- 由于某些原因消息 \_\_\_\_\_\_\_\_ ，为了确保消息不会被无故的丢弃，一般将其置于一个特殊角色的队列，这个队列一般称之为 \_\_\_\_\_\_\_\_

### 1.4 重试队列

- 重试队列其实可以看成是一种回退队列，具体指消费端 \_\_\_\_\_\_\_\_ ，为防止消息无故丢失而 \_\_\_\_\_\_\_\_

### 1.5 消费模式

- \_\_\_\_\_\_\_\_
  - Broker 主动推送消息至消费端， \_\_\_\_\_\_\_\_ ，不过 \_\_\_\_\_\_\_\_ 来确保服务端推送过来的消息 \_\_\_\_\_\_\_\_
- \_\_\_\_\_\_\_\_
  - 消费端主动向 Broker 端请求拉取（一般是 \_\_\_\_\_\_\_\_ ）消息， \_\_\_\_\_\_\_\_ ，但是 \_\_\_\_\_\_\_\_ 而 \_\_\_\_\_\_\_\_

### 1.6 广播消费

- \_\_\_\_\_\_\_\_
  - 对于点对点的模式而言，消息被消费以后， \_\_\_\_\_\_\_\_ ，所以消息消费者 \_\_\_\_\_\_\_\_
- \_\_\_\_\_\_\_\_
  - 一对多广播
- RabbitMQ 是一种典型的点对点模式，而 Kafka 是一种典型的发布订阅模式
  - RabbitMQ 中可以通过 \_\_\_\_\_\_\_\_ 来实现发布订阅模式而 \_\_\_\_\_\_\_\_ 的效果
  - Kafka 中也能以点对点的形式消费，你完全可以把其消费组（consumer group）的概念看成是队列的概念

### 1.7 消息回溯

- 消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息

### 1.8 消息堆积 + 持久化

- \_\_\_\_\_\_\_\_
  - RabbitMQ 是 \_\_\_\_\_\_\_\_ ，但这并非绝对，在某些条件触发后会有换页动作来将内存中的消息换页到磁盘（换页动作会影响吞吐），或者直接使用惰性队列来将消息直接持久化至磁盘中
- \_\_\_\_\_\_\_\_
  - Kafka 是一种 \_\_\_\_\_\_\_\_ ，所有的 \_\_\_\_\_\_\_\_ 。援引 纽约时报的案例，其直接将 Kafka 用作存储系统。

### 1.9 消息追踪

- 基于此功能下，我们可以对发送或者消费完的消息进行 \_\_\_\_\_\_\_\_ ，进而可以进行问题的快速定位与排查。

### 1.10 消息过滤

- 消息过滤是指按照既定的过滤规则 \_\_\_\_\_\_\_\_ 。

### 1.11 多租户

- 多用户的环境下可以确保 \_\_\_\_\_\_\_\_ 。
- RabbitMQ 就能够支持多租户技术，每一个租户表示为一个 vhost，它既能将同一个 RabbitMQ 中的众多客户区分开，又可以避免队列和交换器等命名冲突。

### 1.12 多协议支持

- 一般消息层面的协议有 AMQP、MQTT、STOMP、XMPP 等
- RabbitMQ 能够支持 MQTT 协议就让其在物联网应用中获得一席之地
- Kafka 为典型的基于其本身的私有协议运转

### 1.13 跨语言支持

- 跨语言的支持力度也可以从侧面反映出一个消息中间件的流行程度

### 1.14 流量控制

- 针对的是发送方和接收方 \_\_\_\_\_\_\_\_ 的问题
- 通常的流控方法有 `Stop-and-wait` (数据链路层协议)、`滑动窗口` 以及 `令牌桶` 等。

### 1.15 消息顺序性

- 消息顺序性是指保证消息有序

### 1.16 安全机制

- Kafka 和 RabbitMQ 同样提供安全机制

### 1.17 消息幂等性

- \_\_\_\_\_\_\_\_
  - 至多一次，消息 \_\_\_\_\_\_\_\_ ，但 \_\_\_\_\_\_\_\_
- \_\_\_\_\_\_\_\_
  - 至少一次，消息 \_\_\_\_\_\_\_\_ ，但是 \_\_\_\_\_\_\_\_
- \_\_\_\_\_\_\_\_
  - 精确一次，每条消息 \_\_\_\_\_\_\_\_
  - 很难做到，由此消息幂等性也很难保证

> Kafka 自 0.11 版本开始引入了 \_\_\_\_\_\_\_\_ 和 \_\_\_\_\_\_\_\_ ，Kafka 的 \_\_\_\_\_\_\_\_ ，而 \_\_\_\_\_\_\_\_ ，即写入到多个分区的消息要么全部成功，要么全部回滚，这两个功能加起来可以让 Kafka 具备 EOS（Exactly Once Semantic）的能力。

> 唯一性标识、并且在下游设置一个去重表、状态机

### 1.18 事务性消息

- Kafka 和 RabbitMQ 都支持，不过此两者的事务是指生产者发生消息的事务，要么发送成功，要么发送失败

### 性能

## 2 性能

### 2.1 吞吐量

- 消息中间件的性能一般是指其 \_\_\_\_\_\_\_\_

> 消息中间件的 \_\_\_\_\_\_\_\_ 。就以网卡带宽为例，如果单机单网卡的带宽为 1Gbps，如果要达到百万级的吞吐，那么消息体大小不得超过 (1Gb/8)/100W，即约等于 134B，换句话说如果消息体大小超过 134B，那么就不可能达到百万级别的吞吐。这种计算方式同样可以适用于内存和磁盘。

### 2.2 时延

- 时延作为性能维度的一个重要指标，却往往在消息中间件领域所被忽视，因为一般使用消息中间件的场景 \_\_\_\_\_\_\_\_
- 如果所使用的消息中间件的时延方面比较优秀，那么对于整体系统的性能将会是一个不小的提升。

## 3 可靠性

- 消息中间件的可靠性是指 \_\_\_\_\_\_\_\_
- 对于 Kafka 而言，其采用的是类似 PacificA 的一致性协议， \_\_\_\_\_\_\_\_ ，并且 \_\_\_\_\_\_\_\_
- 对应的 RabbitMQ 是 \_\_\_\_\_\_\_\_
- 在金融支付领域使用 RabbitMQ 居多，而在日志处理、大数据等方面 Kafka 使用居多

> 同步刷盘是增强一个组件可靠性的有效方式，消息中间件也不例外，Kafka 和 RabbitMQ 都可以支持同步刷盘，但是笔者对同步刷盘有一定的疑问：绝大多数情景下，一个组件的可靠性不应该由同步刷盘这种极其损耗性能的操作来保障，而是采用多副本的机制来保证。

## 4 可用性

- 消息中间件的可用性是指 \_\_\_\_\_\_\_\_ ，通常用几个 9 来衡量
- Kafka 的 \_\_\_\_\_\_\_\_ ，其基本上可以达到 \_\_\_\_\_\_\_\_ 的水平，在 LinkedIn 实践介绍中就提及了有部署超过千台设备的 Kafka 集群

## 5 运维管理

- 对于 RabbitMQ 而言，最正统的监控管理工具莫过于 rabbitmq_management 插件了，但是社区内还有 AppDynamics, Collectd, DataDog, Ganglia, Munin, Nagios, New Relic, Prometheus, Zenoss 等多种优秀的产品
- Kafka 在此方面也毫不逊色，比如：Kafka Manager, Kafka Monitor, Kafka Offset Monitor, Burrow, Chaperone, Confluent Control Center 等产品，尤其是 Cruise 还可以提供自动化运维的功能

## 6 社区力度及生态发展

- 在运维管理维度我们提及了 Kafka 和 RabbitMQ 都有一系列开源的监控管理产品，这些正是得益于其社区及生态的迅猛发展。

## 总结

- RabbitMQ 在于 routing，而 Kafka 在于 streaming，了解其根本对于自己能够 \_\_\_\_\_\_\_\_ 。
- 消息中间件选型 \_\_\_\_\_\_\_\_ ， \_\_\_\_\_\_\_\_ ， \_\_\_\_\_\_\_\_ 。如果要在功能和性能方面做一个抉择的话，那么 \_\_\_\_\_\_\_\_ ，因为总体上来说 \_\_\_\_\_\_\_\_ 。然而 \_\_\_\_\_\_\_\_ 。
- 消息中间件选型还有一个考量标准就是 \_\_\_\_\_\_\_\_ ，虽然说没有蹩脚的消息中间件只有蹩脚的程序员，但是让一个 C 栈的团队去深挖 PhxQueue 总比去深挖 Scala 编写的 Kafka 要容易的多。
- 消息中间件大道至简：一发一存一消费，没有最好的消息中间件， \_\_\_\_\_\_\_\_ 。
