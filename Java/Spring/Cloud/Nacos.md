# Nacos

[TOC]

## 服务发现

### Distro 协议

**AP** 分布式协议

* Gossip变种，避免随机同步数据时重复发送数据到同一节点，减轻网络传输压力
* Nacos 每个节点是平等的都可以处理写请求，同时把新数据同步到其他节点
* 每个节点只负责部分数据，定时发送自己负责数据的校验值到其他节点来保持数据一致性
* 每个节点独立处理读请求，即时从本地发出响应

总结

* 数据储存在内存
* 启动全量同步
* 定期数据校验
* 每个节点可读可写
  * 属于当前节点：直接写入
  * 不属于当前节点：集群内部路由转发
  * 任何读请求时，直接在本机查询并返回

## 配置中心

### Nacos 动态刷新原理

Nacos 自动找到那些服务已经注册

#### 数据变更

##### Push
  
服务端主动将数据变更信息推送给客户端

* 长链接
* 耗费内存高，因为需要保存所有客户端连接，并且需要检测连接有效性 **(心跳机制)**

##### Pull

客户端主动拉取数据

* 需要定时拉取数据
* 缺点
  * 时效性
  * 数据实时性
  * 无效请求
  
#### 轮询

##### 短轮询

不管配置是否发生变化，都去发起请求拉取配置

缺点：

* 造成服务器连接压力
* 数据推送延迟

##### 长轮询

客户端发起拉取请求，服务器收到请求后，等待一段时间，如果配置发生变化，立刻返回，否则等待超时检测返回。

优点：

* 服务器不需要与客户端建立长连接
* 能够避免客户端频繁向服务器发送请求

> Nacos 使用客户端**主动拉取**，通过**长轮询** (30s) 等待配置变更机制进行配置数据的获取。


## 基于 Nacos 优雅停服的小坑

1. 在采用金丝雀灰度发布的过程中发现服务已经把原来的注册的服务进行下线操作了，但是仍然有流量请求进来，这样就违背了官方宣称的秒级上下线特点。其中我们服务的负载均衡使用的 ribbon 这个负载均衡组件。
2. 实例下线，是立马更新 server 中的实例信息数据的。
3. 最终虽然实现了秒级的实例上下线，但是由于在 Spring Cloud 中，负载组件 rabbion 的实例信息更新是采用了**定时任务**的形式，有可能这个任务上一秒刚刚执行完，下一秒你就执行实例上下线操作，那么 ribbion 要感知这个变化，就必须要等待 refreshIntervalMs 秒后才可以感知到。所以了解了根源那么我们才能从底层更好地去使用这些组件。